#!/usr/bin/python3
"""
build-image - A script for building a matrix of samba container images.

In order to cleanly implement both logic and maintain backwards compatibility
with image naming schemes already in the wild the build-image script
can be used to create "Fully Qualified Image Names" that combine the
image kind (samba-server, client, etc) and a tag that indicates all
the unique properties of the image. This includes the package source,
the base os, and the architecture.

In addition to building the images, one can push images, list images,
and list build status files (aka buildfiles).

Usage:
  # build an image
  ./hack/build-image --kind server --distro-base fedora --arch amd64

  # print out the FQIN
  ./hack/build-image --kind samba-server --distro-base fedora \\
    --arch amd64 --print

  # print out the FQIN and additional tags
  ./hack/build-image --kind samba-server --distro-base fedora \\
    --arch amd64 --print-tags

  # print out the FQIN and additional tags for multiple images, with
  # and without a repository base
  ./hack/build-image --kind samba-server \\
    --distro-base fedora \\
    --distro-base centos \\
    --distro-base opensuse \\
    --arch amd64 \\
    --repo-base quay.io/foobar --without-repo-bases --print-tags

"""

import argparse
import functools
import json
import logging
import os
import pathlib
import platform
import shlex
import shutil
import subprocess
import sys


logger = logging.getLogger("build-image")

# Set FORCE_ARCH_FLAG if you want to test passing the --arch flag to podman all
# the time. This was the previous behavior but we found it to have some issues.
# When this is false the --arch flag is passed to podman ONLY when the target
# arch != the host system arch.
FORCE_ARCH_FLAG = False

# IMAGE_KINDS - map aliases/names to canonical names for the kinds
# of images we can build
IMG_SERVER = "samba-server"
IMG_AD_SERVER = "samba-ad-server"
IMG_CLIENT = "samba-client"
IMG_TOOLBOX = "samba-toolbox"
IMAGE_KINDS = {
    # short names
    "server": IMG_SERVER,
    "ad-server": IMG_AD_SERVER,
    "client": IMG_CLIENT,
    "toolbox": IMG_TOOLBOX,
    # canonical names
    "samba-server": IMG_SERVER,
    "samba-ad-server": IMG_AD_SERVER,
    "samba-client": IMG_CLIENT,
    "samba-toolbox": IMG_TOOLBOX,
}

# ARCHITECTURES - map supported arch names/alias to canonical names
AMD64 = "amd64"
ARM64 = "arm64"
ARCHITECTURES = {
    # alternate names
    "x86_64": AMD64,
    "aarch64": ARM64,
    # canonical names
    "amd64": AMD64,
    "arm64": ARM64,
}

# DISTROS - list of supported distro bases
FEDORA = "fedora"
CENTOS = "centos"
OPENSUSE = "opensuse"
DISTROS = [
    FEDORA,
    CENTOS,
    OPENSUSE,
]

# PACKAGE_SOURCES - list of known package sources
DEFAULT = "default"
NIGHTLY = "nightly"
DEVBUILDS = "devbuilds"
PACKAGE_SOURCES = [DEFAULT, NIGHTLY, DEVBUILDS]

PACKAGES_FROM = {
    DEFAULT: "",
    NIGHTLY: "samba-nightly",
    DEVBUILDS: "devbuilds",
}

# SOURCE_DIRS - image source paths
# (paths are relative to common image source dir)
SOURCE_DIRS = {
    IMG_SERVER: "server",
    IMG_AD_SERVER: "ad-server",
    IMG_CLIENT: "client",
    IMG_TOOLBOX: "toolbox",
}

DEFAULT_PKG_SOURCES = [DEFAULT]
DEFAULT_DISTRO_BASES = [FEDORA]
LATEST = "latest"
QUAL_NONE = "unqualified"
QUAL_DISTRO = "distro-qualified"
QUAL_FQIN = "fqin"

# conditions
EXISTS = "exists"
AUTO = "auto"
AUTO_INDEX = "auto-index"
REBUILD = "rebuild"


_DISCOVERED_CONTAINER_ENGINES = []


def check_kind(kind):
    """Return the canonical name for the image kind or raise a ValueError."""
    try:
        return IMAGE_KINDS[kind]
    except KeyError:
        raise ValueError(f"invalid kind: {kind}")


def check_arch(arch):
    """Return the canonical name for the arch or raise a ValueError."""
    try:
        return ARCHITECTURES[arch]
    except KeyError:
        raise ValueError(f"invalid arch: {arch}")


def check_distro(distro):
    """Return the canonical name for a distro base or raise a ValueError."""
    if distro in DISTROS:
        return distro
    raise ValueError(f"invalid distro: {distro}")


def check_pkg_source(source):
    """Return the canonical name for a package source or raise a ValueError."""
    if source in PACKAGE_SOURCES:
        return source
    raise ValueError(f"invalid package source: {source}")


def check_repo_base_for(value):
    """Return a tuple with a (distro_base, repo_base) pair or raise a
    ValueError.
    """
    if "=" not in value:
        raise ValueError("expected '=' in value")
    db, rb = value.split("=", 1)
    db = check_distro(db)
    return (db, rb)


def _cmd_to_str(cmd):
    """Format a command for logging."""
    return " ".join(shlex.quote(arg) for arg in cmd)


def run(cli, cmd, capture_output=False, check=False):
    """Execute a command. Wraps subprocess.run."""
    if cli.dry_run and not capture_output:
        logger.info("Would run: %s", _cmd_to_str(cmd))
        return subprocess.CompletedProcess(cmd, 0)
    logger.info("Running: %s", _cmd_to_str(cmd))
    return subprocess.run(cmd, capture_output=capture_output, check=check)


def container_engine(cli):
    """Return the path to a container engine. If the container engine is not
    yet known, discover it and cache the result.
    """
    eng = cli.container_engine
    if eng:
        logger.info("Using specified container engine: %s", eng)
        return eng
    if _DISCOVERED_CONTAINER_ENGINES:
        return _DISCOVERED_CONTAINER_ENGINES[0]
    podman = shutil.which("podman")
    if podman:
        _DISCOVERED_CONTAINER_ENGINES.append(podman)
    docker = shutil.which("docker")
    if docker:
        _DISCOVERED_CONTAINER_ENGINES.append(docker)
    return _DISCOVERED_CONTAINER_ENGINES[0]


def container_build(cli, target):
    """Construct and execute a command to build the target container image."""
    eng = container_engine(cli)
    tasks = []

    # For docker cross-builds we need to use buildx
    if "docker" in eng and target.arch != host_arch():
        args = [eng, "buildx"]

        # Docker's default builder only supports the host architecture.
        # Therefore, we need to create a new builder to support other
        # architectures, and we must ensure we start with a fresh builder
        # that does not contain any images from previous builds.
        tasks.append(
            {"cmd": args + ["rm", target.flat_name()], "check": False}
        )
        tasks.append(
            {
                "cmd": args + ["create", f"--name={target.flat_name()}"],
                "check": True,
            }
        )

        tasks.append(
            {
                "cmd": args
                + [
                    "build",
                    f"--builder={target.flat_name()}",
                    f"--platform=linux/{target.arch}",
                    "--load",
                ]
                + create_common_container_engine_args(cli, target),
                "check": True,
            }
        )

        tasks.append(
            {"cmd": args + ["rm", target.flat_name()], "check": True}
        )
    else:
        args = [eng, "build"]
        if target.arch != host_arch() or FORCE_ARCH_FLAG:
            # We've noticed a few small quirks when using podman with the
            # --arch option. The main issue is that building the client image
            # works but then the toolbox image fails because it somehow doesn't
            # see the image we just built as usable. This doesn't happen when
            # --arch is not provided. So if the target arch and the host_arch
            # are the same, skip passing the extra argument.
            args += [f"--arch={target.arch}"]

        tasks.append(
            {
                "cmd": args
                + create_common_container_engine_args(cli, target),
                "check": True,
            }
        )

    for task in tasks:
        run(cli, **task)


def index_build(cli, target):
    """Construct a new index or manifest."""
    logger.debug("Building index: %s", target)
    eng = container_engine(cli)
    args = [eng, "manifest", "create", target.image_name()]
    run(cli, args, check=True)
    # add images to index
    for img in target.contents:
        add_args = [eng, "manifest", "add"]
        # Currently annotations can't be used for much, but perhaps in the
        # future podman/docker/etc will let you filter on annotations.  Then
        # you could choose base distro, etc using a single big index with
        # annotations indicating various features. For now, it's mostly
        # acedemic and for practice.
        add_args.append(
            "--annotation=org.samba.samba-container.pkg-source="
            f"{img.pkg_source}"
        )
        add_args.append(
            "--annotation=org.samba.samba-container.distro=" f"{img.distro}"
        )
        add_args += [target.image_name(), img.image_name()]
        run(cli, add_args, check=True)
    # apply additional tag names
    for tname in target.all_names(baseless=cli.without_repo_bases):
        tag_args = [eng, "tag", target.image_name(), tname]
        if target.image_name() != tname:
            run(cli, tag_args, check=True)
    # verfication step
    inspect_args = [eng, "manifest", "inspect", target.image_name()]
    res = run(cli, inspect_args, check=True, capture_output=True)
    idx_info = json.loads(res.stdout)
    if len(idx_info["manifests"]) != len(target.contents):
        logger.error("unexpected index info: %r", idx_info)
        logger.error(
            "saw %d entries, expected %d (%r)",
            len(idx_info["manifests"]),
            len(target.contents),
            target.contents,
        )
        raise ValueError("unexpected number of manifest entries")
    return target.image_name()


def image_build(cli, target):
    if isinstance(target, TargetIndex):
        logger.debug("target is an index (or manifest)")
        return index_build(cli, target)
    else:
        logger.debug("target is a container image")
        return container_build(cli, target)


def create_common_container_engine_args(cli, target):
    args = []
    pkgs_from = PACKAGES_FROM[target.pkg_source]
    if pkgs_from:
        args.append(f"--build-arg=INSTALL_PACKAGES_FROM={pkgs_from}")

    if cli.extra_build_arg:
        args.extend(cli.extra_build_arg)

    for tname in target.all_names(baseless=cli.without_repo_bases):
        args.append("-t")
        args.append(tname)

    args.append("-f")
    args.append(target_containerfile(target))
    args.append(kind_source_dir(target.name))
    return [str(a) for a in args]


def container_push(cli, push_name, manifest=False):
    """Construct and execute a command to push a container image."""
    eng = container_engine(cli)
    if manifest:
        args = [eng, "manifest", "push", "--all"]
    else:
        args = [eng, "push"]
    args.append(push_name)
    run(cli, args, check=True)


def container_id(cli, target):
    """Construct and run a command to fetch a hexidecimal id for a container
    image.
    """
    if isinstance(target, TargetIndex):
        args = [
            container_engine(cli),
            "manifest",
            "exists",
            target.image_name(),
        ]
        run(cli, args, check=True)
        return target.image_name()
    args = [
        container_engine(cli),
        "inspect",
        "-f",
        "{{.Id}}",
        target.image_name(),
    ]
    res = run(cli, args, capture_output=True, check=True)
    return res.stdout.decode("utf8").strip()


def maybe_container_id(cli, target):
    """Same as container_id but returns None if no match for the target was
    found.
    """
    try:
        return container_id(cli, target)
    except subprocess.CalledProcessError:
        return None


def container_tag(cli, target, tag, *tags):
    """Add additional tags to the existing target image."""
    if isinstance(target, str):
        src = target  # permit target to be a string w/ the desired source
    else:
        src = target.image_name()
    base_args = [
        container_engine(cli),
        "tag",
        src,
    ]
    if "docker" not in base_args[0]:
        # podman can do it in one command, docker (on github ci) can not
        args = base_args + [tag] + list(tags)
        run(cli, args, check=True)
        return
    for new_tag in [tag] + list(tags):
        run(cli, base_args + [new_tag], check=True)


def kind_source_dir(kind):
    """Return the path to a kind's source directory."""
    return pathlib.Path("images") / SOURCE_DIRS[check_kind(kind)]


def target_containerfile(target):
    """Return the path to a containerfile given an image target."""
    return str(
        kind_source_dir(target.name) / f"Containerfile.{target.distro}"
    )


def host_arch():
    """Return the name of the host's native architecture."""
    return check_arch(platform.machine().lower())


def default_arches():
    """Return a list of the default architectures to use for building."""
    return [host_arch()]


class RepoConfig:
    def __init__(self, default_repo_base, distro_repo=None):
        self.default = default_repo_base
        self.distro_map = dict(distro_repo or [])

    def find_base(self, distro):
        return self.distro_map.get(distro, self.default)


def _split_img(image_name, max_tag_split=3):
    if "/" in image_name:
        base, rest = image_name.rsplit("/", 1)
    else:
        base = ""
        rest = image_name
    iname, tag = rest.split(":", 1)
    tparts = tag.split("-", max_tag_split)
    return base, iname, tparts


class Target:
    def __init__(
        self, name, *, pkg_source, distro, extra_tag="", repo_base=""
    ):
        self.name = name
        self.pkg_source = pkg_source
        self.distro = distro
        self.extra_tag = extra_tag
        self.repo_base = repo_base
        self.additional_tags = []

    def all_names(self, baseless=False):
        yield self.image_name()
        for tag, _ in self.additional_tags:
            yield self.image_name(tag=tag)
        if self.repo_base and baseless:
            yield self.image_name(repo_base="")
            for tag, qual in self.additional_tags:
                if qual == QUAL_NONE:
                    continue
                yield self.image_name(tag=tag, repo_base="")

    def supports_arch(self, arch):
        return False

    def flat_name(self):
        return f"{self.name}.{self.tag_name()}"

    def tag_name(self):
        raise NotImplementedError()

    def image_name(self, *, tag=None, repo_base=None):
        if not tag:
            tag = self.tag_name()
        image_name = f"{self.name}:{tag}"
        repo_base = repo_base if repo_base is not None else self.repo_base
        if repo_base:
            repo_base = repo_base.rstrip("/")
            image_name = f"{repo_base}/{image_name}"
        return image_name

    def __str__(self):
        return self.image_name()


class TargetImage(Target):
    def __init__(
        self, name, pkg_source, distro, arch, extra_tag="", *, repo_base=""
    ):
        super().__init__(
            name,
            pkg_source=pkg_source,
            distro=distro,
            extra_tag=extra_tag,
            repo_base=repo_base,
        )
        self.arch = arch

    def tag_name(self):
        tag_parts = [self.pkg_source, self.distro, self.arch]
        if self.extra_tag:
            tag_parts.append(self.extra_tag)
        tag = "-".join(tag_parts)
        return tag

    def supports_arch(self, arch):
        return arch == self.arch

    @classmethod
    def parse(cls, image_name):
        base, iname, tparts = _split_img(image_name)
        if len(tparts) < 3:
            raise ValueError(f"too few tag components: {tag!r}")
        return cls(
            iname,
            check_pkg_source(tparts[0]),
            check_distro(tparts[1]),
            check_arch(tparts[2]),
            extra_tag=(tparts[3] if len(tparts) > 3 else ""),
            repo_base=base,
        )


class TargetIndex(Target):
    def __init__(
        self,
        name,
        *,
        pkg_source,
        distro,
        contents=None,
        extra_tag="",
        repo_base="",
    ):
        super().__init__(
            name,
            pkg_source=pkg_source,
            distro=distro,
            extra_tag=extra_tag,
            repo_base=repo_base,
        )
        self.contents = contents or []

    def key(self):
        return (self.name, self.pkg_source, self.distro)

    def tag_name(self):
        tag_parts = [self.pkg_source, self.distro]
        if self.extra_tag:
            tag_parts.append(self.extra_tag)
        tag = "-".join(tag_parts)
        return tag

    def merge(self, other):
        assert self.name == other.name
        assert self.pkg_source == other.pkg_source
        assert self.distro == other.distro
        self.contents.extend(other.contents)

    def supports_arch(self, arch):
        return True

    @classmethod
    def from_image(cls, img):
        return cls(
            img.name,
            pkg_source=img.pkg_source,
            distro=img.distro,
            contents=[img],
            repo_base=img.repo_base or "",
        )


class BuildRequest:
    def __init__(self, images=None, indexes=None):
        self.images = list(images or [])
        self.indexes = list(indexes or [])

    def __bool__(self):
        return bool(self.images or self.indexes)

    def expanded(
        self, indexes=False, distro_qualified=True, unqualified=True
    ):
        new_req = self.__class__(self.images, self.indexes)
        if indexes:
            new_req._build_indexes()
        new_req._expand_special_tags(
            distro_qualified=distro_qualified, unqualified=unqualified
        )
        return new_req

    def _expand_special_tags(self, distro_qualified=True, unqualified=True):
        if self.indexes:
            for image in self.indexes:
                # distro qualified is redundant with the default tag of an
                # index/manifest as well as mainly needed for backwards
                # compatibility something we don't want for indexes.
                add_special_tags(
                    image, distro_qualified=False, unqualified=unqualified
                )
        else:
            for image in self.images:
                add_special_tags(
                    image,
                    distro_qualified=distro_qualified,
                    unqualified=unqualified,
                )

    def _build_indexes(self):
        _indexes = {}
        for image in self.images:
            image_index = TargetIndex.from_image(image)
            key = image_index.key()
            if key in _indexes:
                _indexes[key].merge(image_index)
            else:
                _indexes[key] = image_index
        self.indexes = list(_indexes.values())


def generate_request(cli):
    """Given command line parameters with full image names or a matrix of
    kind/pkg_source/distro_base/arch values generate request object containing
    the target images or indexes to build and/or otherwise process.
    """
    images = {}
    for img in cli.image or []:
        images[str(img)] = img
    rc = RepoConfig(cli.repo_base, cli.repo_base_for)
    for kind in cli.kind or []:
        for pkg_source in cli.package_source or DEFAULT_PKG_SOURCES:
            for distro_base in cli.distro_base or DEFAULT_DISTRO_BASES:
                for arch in cli.arch or default_arches():
                    timg = TargetImage(
                        kind,
                        pkg_source,
                        distro_base,
                        arch,
                        extra_tag=(cli.extra_tag or ""),
                        repo_base=rc.find_base(distro_base),
                    )
                    images[str(timg)] = timg
    return BuildRequest(images=images.values()).expanded(
        indexes=cli.combined,
        distro_qualified=cli.distro_qualified,
        unqualified=cli.unqualified,
    )


def add_special_tags(img, distro_qualified=True, unqualified=True):
    """Certain images have special tags. Given an image, add general (non-FQIN)
    tags to that image.
    """
    # Most of the policy (as opposed to mechanism) resides here where we decide
    # that certain images deserve some extra special tags.  Mostly this serves
    # to keep us compatible with older tagging schemes from earlier versions of
    # the project.
    _host_arch = host_arch()
    arch_ok = img.supports_arch(_host_arch)
    if unqualified and img.distro in [FEDORA, OPENSUSE]:
        if arch_ok and img.pkg_source == DEFAULT:
            img.additional_tags.append((LATEST, QUAL_NONE))
        if arch_ok and img.pkg_source == NIGHTLY:
            img.additional_tags.append((NIGHTLY, QUAL_NONE))
    if not distro_qualified:
        return  # skip creating "distro qualified" tags
    if arch_ok and img.pkg_source == DEFAULT:
        img.additional_tags.append((f"{img.distro}-{LATEST}", QUAL_DISTRO))
    if arch_ok and img.pkg_source == NIGHTLY:
        img.additional_tags.append((f"{img.distro}-{NIGHTLY}", QUAL_DISTRO))


def build(cli, target, rebuild=False):
    """Command to build images."""
    build_file = pathlib.Path(f"{cli.buildfile_prefix}{target.flat_name()}")
    common_src = "./images/common"
    common_dst = str(kind_source_dir(target.name) / ".common")
    cid = maybe_container_id(cli, target)
    logger.debug("target: %s, cid=%s, rebuild=%s", target, cid, rebuild)
    if not cid or rebuild:
        logger.debug("Copying common tree: %r -> %r", common_src, common_dst)
        shutil.copytree(common_src, common_dst, dirs_exist_ok=True)
        image_build(cli, target)
        cid = container_id(cli, target)
    with open(build_file, "w") as fh:
        fh.write(f"{cid} {target.image_name()}\n")


def rebuild(cli, target):
    return build(cli, target, rebuild=True)


class QMatcher:
    """Push only tags that meet the specified criteria:
    all - all tags;
    unqualified - only unqualified tags (eg. latest);
    distro - only distribution base qualifed tags (eg. fedora-latest);
    fqin - only fully qualified tags (eg. default-centos-amd64);
    mixed - only fqin and unqualified tags;
    least-qualified (default) - exactly one tag, with the least
    number of qualifications
    """

    def __init__(self, key):
        self.qualifications = []
        self.count = 0
        self.max_matches = 0

        if not key or key == "least-qualified":
            self.qualifications = [QUAL_NONE, QUAL_DISTRO, QUAL_FQIN]
            self.max_matches = 1
        elif key == "all":
            pass
        elif key == "mixed":
            self.qualifications = [QUAL_NONE, QUAL_FQIN]
        else:
            try:
                mq = {
                    "unqualified": QUAL_NONE,
                    "distro": QUAL_DISTRO,
                    "fqin": QUAL_FQIN,
                }[key]
            except KeyError:
                raise argparse.ArgumentTypeError(
                    "value must be one of:"
                    " all, least-qualified, unqualified, distro, fqin;"
                    f" not {key}"
                )
            self.qualifications = [mq]

    def __call__(self, qv):
        if self.max_matches and self.count >= self.max_matches:
            return False
        if not self.qualifications or qv in self.qualifications:
            self.count += 1
            return True
        return False


def _autobuild(cli, target, is_index=None):
    if is_index is None:
        is_index = isinstance(target, TargetIndex)
    if cli.condition == REBUILD:
        rebuild(cli, target)
    elif maybe_container_id(cli, target):
        logger.debug("target item exists: %s", target)
    elif cli.condition == AUTO or (cli.condition == AUTO_INDEX and is_index):
        logger.debug("target item auto build: %s", target)
        build(cli, target)
    else:
        log.error("no existing image or index: %s", target)
        raise ValueError("not present", target)


def push(cli, target):
    """Command to push images."""
    is_index = isinstance(target, TargetIndex)  # is it a manifest push?
    _autobuild(cli, target, is_index=is_index)

    to_push = []
    push_name = target.image_name()
    for tag, qual in target.additional_tags:
        if tag in ("latest", "nightly"):
            to_push.append((target.image_name(tag=tag), qual))
        if tag.endswith(("-latest", "-nightly")):
            to_push.append((target.image_name(tag=tag), qual))
    to_push.append((push_name, QUAL_FQIN))
    qmatcher = cli.push_selected_tags or QMatcher("")
    for push_name, tag_qual in to_push:
        if qmatcher(tag_qual):
            logger.debug(
                "pushing named object: %s (manifest=%s)", push_name, is_index
            )
            container_push(cli, push_name, manifest=is_index)


def archive(cli, target, location):
    """Write tarballs to archive location."""
    if isinstance(target, TargetIndex):
        return  # ignore indexes/manifests
    _autobuild(cli, target)

    eng = container_engine(cli)
    fname = pathlib.Path(location) / f"{target.flat_name()}.tar"
    args = [eng, "save", f"-o{fname}", target.image_name()]
    run(cli, args, check=True)


def load_archived(cli, target, location):
    """Load tarballs from archive location."""
    fname = pathlib.Path(location) / f"{target.flat_name()}.tar"
    logger.info("Loading from: %s", fname)

    eng = container_engine(cli)
    args = [eng, "load", f"-i{fname}"]
    run(cli, args, check=True)


def retag(cli, target):
    """Command to regenerate any missing unqualified tags."""
    cid = container_id(cli, target)
    tags = []
    if cli.repo_base and target.repo_base != cli.repo_base:
        # if repo base is given on the cli, and differs from the
        # target, regenerate tags with the new distro base.
        # retag list
        target.repo_base = cli.repo_base
        # Ensure the new FQIN is part of the new tags list
        tags.append(target.image_name())
    tags += [target.image_name(tag=t) for t, _ in target.additional_tags]
    if tags:
        container_tag(cli, cid, *tags)
    else:
        logger.warning("no tags to add")


def print_buildfile(cli, target):
    """Command to print build file names."""
    build_file = pathlib.Path(f"{cli.buildfile_prefix}{target.flat_name()}")
    print(build_file)


def print_image(_, target):
    """Command to print (fqin) image names."""
    print(str(target))


def print_tags(cli, target):
    """Command to print fqin image and additinal tag names."""
    for idx, name in enumerate(
        target.all_names(baseless=cli.without_repo_bases)
    ):
        prefix = "" if idx == 0 else "  "
        print(f"{prefix}{name}")


def _kwbind(func, key, conversion=None):
    """Attach an argument value to a command-linked argument."""

    def _capture(arg_value):
        value = conversion(arg_value) if conversion else arg_value
        return functools.partial(func, **{key: value})

    return _capture


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--verbose",
        dest="log_level",
        action="store_const",
        const=logging.INFO,
        default=logging.WARNING,
        help="Emit verbose output",
    )
    parser.add_argument(
        "--debug",
        dest="log_level",
        action="store_const",
        const=logging.DEBUG,
        default=logging.WARNING,
        help="Emit debug level output",
    )
    parser.add_argument(
        "--repo-base",
        "-R",
        help=(
            "Common container registry repository base"
            " (eg. quay.io/samba.org)"
        ),
    )
    parser.add_argument(
        "--image",
        "-i",
        type=TargetImage.parse,
        action="append",
        help="Build precisely the named image (requires a FQIN)",
    )
    parser.add_argument(
        "--kind",
        "-k",
        type=check_kind,
        action="append",
        help="The kind of container to build (server, ad-server, etc...)",
    )
    parser.add_argument(
        "--distro-base",
        "-d",
        type=check_distro,
        action="append",
        help="The name of the base OS distribution to use.",
    )
    parser.add_argument(
        "--repo-base-for",
        "-F",
        type=check_repo_base_for,
        action="append",
        help=(
            "Assign a custom repo base given a distro base"
            "(like: --repo-base-for=centos=wonky.io/smb)"
        ),
    )
    parser.add_argument(
        "--arch",
        "-a",
        type=check_arch,
        action="append",
        help="The name of the CPU architecture to build for",
    )
    parser.add_argument(
        "--package-source",
        "-p",
        type=check_pkg_source,
        action="append",
        help="Source of Samba packages to use",
    )
    parser.add_argument(
        "--container-engine",
        help=(
            "Expliclty specify the path to the container engine"
            " (docker, podman, ...) to use"
        ),
    )
    parser.add_argument(
        "--extra-tag",
        help="Specify an extra tag extension. Handy for developers.",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Do not run build commands"
    )
    parser.add_argument(
        "--push-state",
        "--image-condition",
        dest="condition",
        choices=(EXISTS, AUTO, AUTO_INDEX, REBUILD),
        default=EXISTS,
        help=(
            "Image state must be met before continuing:"
            " exists - item already exists;"
            " auto - automatically build missing image;"
            " auto-index - automatically build missing indexes only;"
            " rebuild - image must be rebuilt."
        ),
    )
    parser.add_argument(
        "--push-selected-tags",
        type=QMatcher,
        help=QMatcher.__doc__,
    )
    parser.add_argument(
        "--buildfile-prefix",
        default=".build.",
        help="Specify prefix for build status files",
    )
    parser.add_argument(
        "--extra-build-arg",
        "-x",
        action="append",
        help="Extra argument to pass to container build command",
    )
    parser.add_argument(
        "--without-repo-bases",
        "-w",
        action="store_true",
        help=(
            "If an image has a repo base, also generate image names"
            " without the repo base"
        ),
    )
    parser.add_argument(
        "--distro-qualified",
        action=argparse.BooleanOptionalAction,
        default=True,
        help=(
            "Specify if image tags like 'fedora-nightly' or 'centos-latest'"
            " will be created."
        ),
    )
    parser.add_argument(
        "--unqualified",
        action=argparse.BooleanOptionalAction,
        default=True,
        help=(
            "Specify if image tags like 'nightly' or 'latest' will be created."
        ),
    )
    parser.add_argument(
        "--combined",
        action=argparse.BooleanOptionalAction,
        default=False,
        help=("Specify if manifests/image indexes should be created."),
    )

    behaviors = parser.add_mutually_exclusive_group()
    behaviors.add_argument(
        "--push",
        action="store_const",
        dest="main_action",
        const=push,
        help="Push images",
    )
    behaviors.add_argument(
        "--print",
        action="store_const",
        dest="main_action",
        const=print_image,
        help="Print the image names selected",
    )
    behaviors.add_argument(
        "--print-tags",
        action="store_const",
        dest="main_action",
        const=print_tags,
        help="Print the image and additional tags selected",
    )
    behaviors.add_argument(
        "--print-buildfile",
        action="store_const",
        dest="main_action",
        const=print_buildfile,
        help="Print the names of build status files",
    )
    behaviors.add_argument(
        "--retag",
        action="store_const",
        dest="main_action",
        const=retag,
        help=(
            "Regenerate any short (unqualified) tags expected to exist"
            " for a given FQIN. Requires FQIN to already exist locally."
        ),
    )
    behaviors.add_argument(
        "--rebuild",
        action="store_const",
        dest="main_action",
        const=rebuild,
        help="Always rebuild images even if matching images exist locally.",
    )
    behaviors.add_argument(
        "--archive",
        metavar="LOCATION",
        dest="main_action",
        type=_kwbind(archive, "location"),
        help="Write archive files (tarballs) to a specified location",
    )
    behaviors.add_argument(
        "--load",
        metavar="LOCATION",
        dest="main_action",
        type=_kwbind(load_archived, "location"),
        help="Read in archive files (tarballs) from a specified location",
    )
    cli = parser.parse_args()

    if os.environ.get("BUILD_IMAGE_DEBUG") in ("1", "yes"):
        cli.log_level = logging.DEBUG
    logging.basicConfig(level=cli.log_level)

    _action = cli.main_action if cli.main_action else build
    req = None
    try:
        req = generate_request(cli)
        for img in req.images:
            logger.info("Image %s, extra tags: %s", img, img.additional_tags)
            _action(cli, img)
        for index in req.indexes:
            logger.info(
                "Index (Manifest) %s, extra tags: %s",
                index,
                index.additional_tags,
            )
            _action(cli, index)
    except subprocess.CalledProcessError as err:
        logger.error("Failed command: %s", _cmd_to_str(err.cmd))
        sys.exit(err.returncode)
    if not req:
        logger.error("No images or image kinds supplied")
        sys.exit(2)


if __name__ == "__main__":
    main()
